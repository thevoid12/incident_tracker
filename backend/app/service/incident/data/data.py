"""
Data access layer for incident service.
Handles all database operations for incident management with proper logging.
"""

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, func, and_, or_
from core import LOGGER, DatabaseError
from service.db.models.incident_model import Incident


class IncidentDataAccess:
    """Data access class for incident operations"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def create_incident(self, title: str, description: str, status: str, priority: str,
                            created_by: str) -> Incident:
        """Create a new incident in the database"""
        try:
            LOGGER.debug(f"Creating incident with title: {title}")

            # Create incident instance (ID will be auto-generated by SERIAL)
            # Note: created_on and updated_on will use database defaults (CURRENT_TIMESTAMP)
            incident = Incident(
                title=title,
                description=description,
                status=status,
                priority=priority,
                created_by=created_by,
                updated_by=created_by
            )

            # Add to database
            self.db.add(incident)
            await self.db.commit()
            # telling SQLAlchemy to reload the object from the database,
            # populating all the database-generated fields with their
            # actual values.
            await self.db.refresh(incident)

            LOGGER.info(f"Incident created successfully with ID: {incident.id}")
            return incident

        except Exception as e:
            LOGGER.error(f"Failed to create incident {title}: {str(e)}")
            await self.db.rollback()
            raise DatabaseError(f"Failed to create incident: {str(e)}", operation="create_incident")

    async def get_incident_by_id(self, incident_id: str) -> Incident | None:
        """Get incident by ID"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Querying incident by ID: {incident_id} (converted to int: {incident_id_int})")

            result = await self.db.execute(
                select(Incident).where(
                    and_(Incident.id == incident_id_int, Incident.is_deleted == False)
                )
            )
            incident = result.scalar_one_or_none()

            if incident:
                LOGGER.debug(f"Incident found: {incident_id}")
            else:
                LOGGER.debug(f"No incident found with ID: {incident_id}")

            return incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="get_incident_by_id")
        except Exception as e:
            LOGGER.error(f"Failed to query incident by ID {incident_id}: {str(e)}")
            raise DatabaseError(f"Failed to query incident: {str(e)}", operation="get_incident_by_id")

    async def get_incidents_paginated(self, limit: int, offset: int) -> tuple[list[Incident], int]:
        """Get incidents with pagination only (no filtering)"""
        try:
            LOGGER.debug(f"Querying incidents with pagination: limit={limit}, offset={offset}")

            # Build base query - only exclude deleted incidents
            query = select(Incident).where(Incident.is_deleted == False)

            # Get total count of all non-deleted incidents
            count_query = select(func.count()).select_from(query.subquery())
            total_count_result = await self.db.execute(count_query)
            total_count = total_count_result.scalar()

            # Apply pagination using limit and offset
            query = query.offset(offset).limit(limit)

            # Execute query
            result = await self.db.execute(query)
            incidents = result.scalars().all()

            LOGGER.debug(f"Found {len(incidents)} incidents out of {total_count} total")
            return incidents, total_count

        except Exception as e:
            LOGGER.error(f"Failed to query incidents with pagination: {str(e)}")
            raise DatabaseError(f"Failed to query incidents: {str(e)}", operation="get_incidents_paginated")

    async def update_incident(self, incident_id: str, update_data: dict, updated_by: str) -> Incident:
        """Update an existing incident"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Updating incident {incident_id} (converted to int: {incident_id_int}) with data: {update_data}")

            # Add updated_by to the update data
            update_data['updated_by'] = updated_by

            # Execute update
            result = await self.db.execute(
                update(Incident)
                .where(and_(Incident.id == incident_id_int, Incident.is_deleted == False))
                .values(**update_data)
                .returning(Incident)
            )

            updated_incident = result.scalar_one_or_none()

            if not updated_incident:
                LOGGER.warning(f"No incident found with ID: {incident_id}")
                raise DatabaseError("Incident not found", operation="update_incident")

            await self.db.commit()
            await self.db.refresh(updated_incident)

            LOGGER.info(f"Incident updated successfully: {incident_id}")
            return updated_incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="update_incident")
        except Exception as e:
            LOGGER.error(f"Failed to update incident {incident_id}: {str(e)}")
            await self.db.rollback()
            if isinstance(e, DatabaseError):
                raise
            raise DatabaseError(f"Failed to update incident: {str(e)}", operation="update_incident")

    async def soft_delete_incident(self, incident_id: str, deleted_by: str) -> bool:
        """Soft delete an incident"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Soft deleting incident: {incident_id} (converted to int: {incident_id_int})")

            # Execute soft delete
            result = await self.db.execute(
                update(Incident)
                .where(and_(Incident.id == incident_id_int, Incident.is_deleted == False))
                .values(is_deleted=True, updated_by=deleted_by)
            )

            if result.rowcount == 0:
                LOGGER.warning(f"No incident found with ID: {incident_id}")
                return False

            await self.db.commit()
            LOGGER.info(f"Incident soft deleted successfully: {incident_id}")
            return True

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="soft_delete_incident")
        except Exception as e:
            LOGGER.error(f"Failed to soft delete incident {incident_id}: {str(e)}")
            await self.db.rollback()
            raise DatabaseError(f"Failed to delete incident: {str(e)}", operation="soft_delete_incident")