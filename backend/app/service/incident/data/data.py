"""
Data access layer for incident service.
Handles all database operations for incident management with proper logging.
"""

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, func, and_, or_
from core import LOGGER, DatabaseError
from datetime import datetime,timezone
from service.db.models.incident_model import Incident
from sqlalchemy.orm.attributes import flag_modified

class IncidentDataAccess:
    """Data access class for incident operations"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def create_incident(self, title: str, description: str, status: str, priority: str,
                             assigned_to: str, created_by: str) -> Incident:
        """Create a new incident in the database"""
        try:
            LOGGER.debug(f"Creating incident with title: {title}")

            # Create incident instance (ID will be auto-generated by SERIAL)
            # Note: created_on and updated_on will use database defaults (CURRENT_TIMESTAMP)
            incident = Incident(
                title=title,
                description=description,
                status=status,
                priority=priority,
                assigned_to=assigned_to,
                created_by=created_by,
                updated_by=created_by
            )

            # Add to database session
            self.db.add(incident)
            # Note: Transaction commit and refresh moved to service layer
            # This prevents "not persistent" errors when refresh is called before commit

            LOGGER.info(f"Incident added to session with title: {title}")
            return incident

        except Exception as e:
            LOGGER.error(f"Failed to create incident {title}: {str(e)}")
            # Note: Transaction rollback handled by service layer
            raise DatabaseError(f"Failed to create incident: {str(e)}", operation="create_incident")

    async def get_incident_by_id(self, incident_id: str, emailID: str) -> Incident | None:
        """Get incident by ID and created_by"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Querying incident by ID: {incident_id} (converted to int: {incident_id_int}) for user: {emailID}")

            result = await self.db.execute(
                select(Incident).where(
                    and_(
                        Incident.id == incident_id_int,
                        Incident.is_deleted == False,
                        or_(Incident.created_by == emailID, Incident.assigned_to ==emailID)
                    )
                )
            )
            incident = result.scalar_one_or_none()

            if incident:
                LOGGER.debug(f"Incident found: {incident_id}")
            else:
                LOGGER.debug(f"No incident found with ID: {incident_id} for user: {emailID}")

            return incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="get_incident_by_id")
        except Exception as e:
            LOGGER.error(f"Failed to query incident by ID {incident_id}: {str(e)}")
            raise DatabaseError(f"Failed to query incident: {str(e)}", operation="get_incident_by_id")

    async def list_incidents_paginated(self, limit: int, offset: int, emailID: str) -> tuple[list[Incident], int]:
        """List incidents with pagination filtered by created_by and assigned to"""
        try:
            LOGGER.debug(f"Querying incidents with pagination: limit={limit}, offset={offset} for user: {emailID}")

            # Build base query - exclude deleted incidents and filter by created_by
            query = select(Incident).where(
                and_(Incident.is_deleted == False,or_(Incident.created_by == emailID,Incident.assigned_to==emailID))
            )

            # Get total count of non-deleted incidents for this user
            count_query = select(func.count()).select_from(query.subquery())
            total_count_result = await self.db.execute(count_query)
            total_count = total_count_result.scalar()

            # Apply pagination using limit and offset
            query = query.offset(offset).limit(limit)

            # Execute query
            result = await self.db.execute(query)
            incidents = result.scalars().all()

            LOGGER.debug(f"Found {len(incidents)} incidents out of {total_count} total for user: {emailID}")
            return incidents, total_count

        except Exception as e:
            LOGGER.error(f"Failed to query incidents with pagination: {str(e)}")
            raise DatabaseError(f"Failed to query incidents: {str(e)}", operation="get_incidents_paginated")

    async def update_incident(self, incident_id: str, update_data: dict, updated_by: str, emailID: str) -> Incident:
        """Update an existing incident - only if created by the same user"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Updating incident {incident_id} (converted to int: {incident_id_int}) with data: {update_data} for user: {emailID}")

            # Add updated_by to the update data
            update_data['updated_by'] = updated_by

            # Execute update - only allow update if incident was created by the same user
            result = await self.db.execute(
                update(Incident)
                .where(and_(
                    Incident.id == incident_id_int,
                    Incident.is_deleted == False,
                    or_(Incident.created_by == emailID,Incident.assigned_to==emailID)
                ))
                .values(**update_data)
                .returning(Incident)
            )

            updated_incident = result.scalar_one_or_none()

            if not updated_incident:
                LOGGER.warning(f"No incident found with ID: {incident_id} for user: {emailID}")
                raise DatabaseError("Incident not found or access denied", operation="update_incident")

            # Note: Transaction management moved to service layer
            await self.db.refresh(updated_incident)

            LOGGER.info(f"Incident updated successfully: {incident_id}")
            return updated_incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="update_incident")
        except Exception as e:
            LOGGER.error(f"Failed to update incident {incident_id}: {str(e)}")
            # Note: Transaction rollback handled by service layer
            if isinstance(e, DatabaseError):
                raise
            raise DatabaseError(f"Failed to update incident: {str(e)}", operation="update_incident")

    async def soft_delete_incident(self, incident_id: str, deleted_by: str, created_by: str) -> bool:
        """Soft delete an incident - only if created by the same user"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Soft deleting incident: {incident_id} (converted to int: {incident_id_int}) for user: {created_by}")

            # Execute soft delete - only allow delete if incident was created by the same user
            result = await self.db.execute(
                update(Incident)
                .where(and_(
                    Incident.id == incident_id_int,
                    Incident.is_deleted == False,
                    Incident.created_by == created_by
                ))
                .values(is_deleted=True, updated_by=deleted_by)
            )

            if result.rowcount == 0:
                LOGGER.warning(f"No incident found with ID: {incident_id} for user: {created_by}")
                return False

            # Note: Transaction management moved to service layer
            LOGGER.info(f"Incident soft deleted successfully: {incident_id}")
            return True

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="soft_delete_incident")
        except Exception as e:
            LOGGER.error(f"Failed to soft delete incident {incident_id}: {str(e)}")
            # Note: Transaction rollback handled by service layer
            raise DatabaseError(f"Failed to delete incident: {str(e)}", operation="soft_delete_incident")

    async def add_chat_message(self, incident_id: str, user_email: str, content: str, emailID: str) -> Incident:
        """Add a message to the incident's chat"""
        try:
            
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Adding chat message to incident {incident_id} by user: {user_email}")

            # Get current incident
            result = await self.db.execute(
                select(Incident).where(
                    and_(
                        Incident.id == incident_id_int,
                        Incident.is_deleted == False,
                        or_(Incident.created_by == emailID, Incident.assigned_to == emailID)
                    )
                )
            )
            incident = result.scalar_one_or_none()

            if not incident:
                LOGGER.warning(f"No incident found with ID: {incident_id} for user: {emailID}")
                raise DatabaseError("Incident not found or access denied", operation="add_chat_message")

            # Initialize chat if None
            if incident.chat is None:
                incident.chat = []

            # Add new message
            new_message = {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "useremail": user_email,
                "content": content
            }
            incident.chat.append(new_message)

            # Mark the chat field as modified for SQLAlchemy
            # SQLAlchemy Issue: When you modify nested data in a JSON field, SQLAlchemy doesn't automatically detect the change
            # Without flag_modified: The commit happens but the JSON field isn't updated in the database
            # With flag_modified: SQLAlchemy knows the field changed and properly saves it
            flag_modified(incident, 'chat')

            # Note: Transaction management moved to service layer
            # Refresh will be handled by service layer after commit

            LOGGER.info(f"Chat message added to incident: {incident_id}")
            return incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="add_chat_message")
        except Exception as e:
            LOGGER.error(f"Failed to add chat message to incident {incident_id}: {str(e)}")
            # Note: Transaction rollback handled by service layer
            raise DatabaseError(f"Failed to add chat message: {str(e)}", operation="add_chat_message")

    async def bulk_create_incidents(self, incidents_data: list[dict], created_by: str) -> list[Incident]:
        """Bulk create multiple incidents in a single transaction"""
        try:
            LOGGER.debug(f"Bulk creating {len(incidents_data)} incidents for user: {created_by}")

            incidents = []
            for data in incidents_data:
                incident = Incident(
                    title=data['title'],
                    description=data.get('description'),
                    status=data['status'],
                    priority=data['priority'],
                    assigned_to=data['assigned_to'],
                    created_by=created_by,
                    updated_by=created_by
                )
                incidents.append(incident)
                self.db.add(incident)

            # Flush to generate IDs but don't commit yet
            await self.db.flush()

            # Refresh all incidents to get their IDs
            for incident in incidents:
                await self.db.refresh(incident)

            LOGGER.info(f"Bulk created {len(incidents)} incidents for user: {created_by}")
            return incidents

        except Exception as e:
            LOGGER.error(f"Failed to bulk create incidents: {str(e)}")
            raise DatabaseError(f"Failed to bulk create incidents: {str(e)}", operation="bulk_create_incidents")