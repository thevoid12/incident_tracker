"""
Data access layer for incident service.
Handles all database operations for incident management with proper logging.
"""

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, func, and_, or_
from core import LOGGER, DatabaseError
from service.db.models.incident_model import Incident


class IncidentDataAccess:
    """Data access class for incident operations"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def create_incident(self, title: str, description: str, status: str, priority: str,
                            created_by: str) -> Incident:
        """Create a new incident in the database"""
        try:
            LOGGER.debug(f"Creating incident with title: {title}")

            # Create incident instance (ID will be auto-generated by SERIAL)
            # Note: created_on and updated_on will use database defaults (CURRENT_TIMESTAMP)
            incident = Incident(
                title=title,
                description=description,
                status=status,
                priority=priority,
                created_by=created_by,
                updated_by=created_by
            )

            # Add to database
            self.db.add(incident)
            await self.db.commit()
            # telling SQLAlchemy to reload the object from the database,
            # populating all the database-generated fields with their
            # actual values.
            await self.db.refresh(incident)

            LOGGER.info(f"Incident created successfully with ID: {incident.id}")
            return incident

        except Exception as e:
            LOGGER.error(f"Failed to create incident {title}: {str(e)}")
            await self.db.rollback()
            raise DatabaseError(f"Failed to create incident: {str(e)}", operation="create_incident")

    async def get_incident_by_id(self, incident_id: str, created_by: str) -> Incident | None:
        """Get incident by ID and created_by"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Querying incident by ID: {incident_id} (converted to int: {incident_id_int}) for user: {created_by}")

            result = await self.db.execute(
                select(Incident).where(
                    and_(
                        Incident.id == incident_id_int,
                        Incident.is_deleted == False,
                        Incident.created_by == created_by
                    )
                )
            )
            incident = result.scalar_one_or_none()

            if incident:
                LOGGER.debug(f"Incident found: {incident_id}")
            else:
                LOGGER.debug(f"No incident found with ID: {incident_id} for user: {created_by}")

            return incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="get_incident_by_id")
        except Exception as e:
            LOGGER.error(f"Failed to query incident by ID {incident_id}: {str(e)}")
            raise DatabaseError(f"Failed to query incident: {str(e)}", operation="get_incident_by_id")

    async def get_incidents_paginated(self, limit: int, offset: int, created_by: str) -> tuple[list[Incident], int]:
        """Get incidents with pagination filtered by created_by"""
        try:
            LOGGER.debug(f"Querying incidents with pagination: limit={limit}, offset={offset} for user: {created_by}")

            # Build base query - exclude deleted incidents and filter by created_by
            query = select(Incident).where(
                and_(Incident.is_deleted == False, Incident.created_by == created_by)
            )

            # Get total count of non-deleted incidents for this user
            count_query = select(func.count()).select_from(query.subquery())
            total_count_result = await self.db.execute(count_query)
            total_count = total_count_result.scalar()

            # Apply pagination using limit and offset
            query = query.offset(offset).limit(limit)

            # Execute query
            result = await self.db.execute(query)
            incidents = result.scalars().all()

            LOGGER.debug(f"Found {len(incidents)} incidents out of {total_count} total for user: {created_by}")
            return incidents, total_count

        except Exception as e:
            LOGGER.error(f"Failed to query incidents with pagination: {str(e)}")
            raise DatabaseError(f"Failed to query incidents: {str(e)}", operation="get_incidents_paginated")

    async def update_incident(self, incident_id: str, update_data: dict, updated_by: str, created_by: str) -> Incident:
        """Update an existing incident - only if created by the same user"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Updating incident {incident_id} (converted to int: {incident_id_int}) with data: {update_data} for user: {created_by}")

            # Add updated_by to the update data
            update_data['updated_by'] = updated_by

            # Execute update - only allow update if incident was created by the same user
            result = await self.db.execute(
                update(Incident)
                .where(and_(
                    Incident.id == incident_id_int,
                    Incident.is_deleted == False,
                    Incident.created_by == created_by
                ))
                .values(**update_data)
                .returning(Incident)
            )

            updated_incident = result.scalar_one_or_none()

            if not updated_incident:
                LOGGER.warning(f"No incident found with ID: {incident_id} for user: {created_by}")
                raise DatabaseError("Incident not found or access denied", operation="update_incident")

            await self.db.commit()
            await self.db.refresh(updated_incident)

            LOGGER.info(f"Incident updated successfully: {incident_id}")
            return updated_incident

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="update_incident")
        except Exception as e:
            LOGGER.error(f"Failed to update incident {incident_id}: {str(e)}")
            await self.db.rollback()
            if isinstance(e, DatabaseError):
                raise
            raise DatabaseError(f"Failed to update incident: {str(e)}", operation="update_incident")

    async def soft_delete_incident(self, incident_id: str, deleted_by: str, created_by: str) -> bool:
        """Soft delete an incident - only if created by the same user"""
        try:
            # Convert string ID to integer for database query
            incident_id_int = int(incident_id)
            LOGGER.debug(f"Soft deleting incident: {incident_id} (converted to int: {incident_id_int}) for user: {created_by}")

            # Execute soft delete - only allow delete if incident was created by the same user
            result = await self.db.execute(
                update(Incident)
                .where(and_(
                    Incident.id == incident_id_int,
                    Incident.is_deleted == False,
                    Incident.created_by == created_by
                ))
                .values(is_deleted=True, updated_by=deleted_by)
            )

            if result.rowcount == 0:
                LOGGER.warning(f"No incident found with ID: {incident_id} for user: {created_by}")
                return False

            await self.db.commit()
            LOGGER.info(f"Incident soft deleted successfully: {incident_id}")
            return True

        except ValueError as e:
            LOGGER.error(f"Invalid incident ID format: {incident_id}")
            raise DatabaseError(f"Invalid incident ID format: {incident_id}", operation="soft_delete_incident")
        except Exception as e:
            LOGGER.error(f"Failed to soft delete incident {incident_id}: {str(e)}")
            await self.db.rollback()
            raise DatabaseError(f"Failed to delete incident: {str(e)}", operation="soft_delete_incident")